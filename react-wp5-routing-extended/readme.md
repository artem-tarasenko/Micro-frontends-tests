## React micro-frontend example with dymanic routing

This example takes a step further from `react-wp5-routing` to see how to register each provided remote component into routing and navigation.

### Run application

Run commands in each folder (separate appllication)

```bash
npm ci
```

```bash
npm run serve
```

Open `localhost:3000` to see root application

Other apps:
`localhost:3001` - app1
`localhost:3002` - app2

### Docker

```bash
docker-compose up
```

### About this demo

![App2 diagram](diagram.jpg?raw=true "App2 diagram")

This application shows how navigation in the root app could be implemented to consume remote modules and make a link and a route for each one automatically.

`react-wp5-routing` application has a navigation in a root component where each MFE has to be imported and manually mounted on a prepared "wrapper" page of a root component. In this example remote MFE doesn't have a wrapper page but mounts as a page directly.

This is done by exposing not just a remote module by webpack plugin but an object that contains data necessary for a routing: 
- name of the route
- component to mount
- url when it should be mounted

Root application register all routes based on a combination of exposed "routes" files and a local copy that contains predefined root app's routes (if needed).

```js
const routes = [
    {
        path: String,
        module: React.Component,
        name: String,
    },
    ...Remote routes,
]

```

Remote modules can have it own sub-navigation. For such routes to work properly the following should be done:
- Remote app with subnav should contain subroutes in the exposed object.
- Root app will see subroutes and register them recoursively (there is a utility finction in routing.js)
- Links, as they are part of a remote app should naturally be in an appropriate component.

```js
const routes = [
    {
        path: String,
        module: React.Component,
        name: String,
      + subroutes: [
            {},
        ]
    },
    ...Remote routes,
]

```

Exposed files presumably must have unique names (this should be tested).

At this point, adding a component represented as a new page with link in the root menu, the following steps must be done:
- Add new compoennt in either remote App1 or App2
- Add new object to `routesApp*` array (as a lazy loaded component)
- Build and serve new exposed bundle (remoteEntry.js generated by webpack)
- Reload page on the root app

Additionaly, there are several styling approaches tested: styled-components, SCSS, Css modules.

